/*
 * (C) Copyright 2007-2011
 * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
 * Tom Cubie <tangliang@allwinnertech.com>
 *
 * Boot an image which is generated by android mkbootimg tool
 *
 * (C) Copyright 2000-2003
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

/*
 * Misc boot support
 */
#include <common.h>
#include <command.h>
#include <net.h>

#ifdef CONFIG_CMD_BOOTA
DECLARE_GLOBAL_DATA_PTR;

#include <fastboot.h>

void do_boota_linux(bootm_headers_t *, struct fastboot_boot_img_hdr *);

/*
 * If everything is successful, this function will never return because
 * the kernel was launched.  Even if control never returns, the kernel
 * may have other failures which keep the system from coming up fully.
 */
int do_boota(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
{
	ulong addr;
	struct fastboot_boot_img_hdr *fb_hdr;

	if (argc < 2)
		return cmd_usage(cmdtp);

	addr = simple_strtoul(argv[1], NULL, 16);

	fb_hdr = (struct fastboot_boot_img_hdr *)addr;

	if (memcmp(fb_hdr->magic, FASTBOOT_BOOT_MAGIC, 8)) {
		puts("boota: bad boot image magic, maybe not a boot.img?\n");
		return 1;
	}
#ifdef DEBUG
	printf("---------------------\n");
	printf("kernel_size: 0x%x\n", fb_hdr->kernel_size);
	printf("kernel_addr: 0x%x\n\n", fb_hdr->kernel_addr);

	printf("ramdisk_size: 0x%x\n", fb_hdr->ramdisk_size);
	printf("ramdisk_addr: 0x%x\n\n", fb_hdr->ramdisk_addr);

	printf("second_size: 0x%x\n", fb_hdr->second_size);
	printf("second_addr: 0x%x\n\n", fb_hdr->second_addr);

	printf("tags_addr:  0x%x\n\n", fb_hdr->tags_addr);

	printf("page_size:  0x%x\n\n", fb_hdr->page_size);

	if (fb_hdr->unused[0] || fb_hdr->unused[1]) {
		printf("***** ERROR unused:  0x%x 0x%x\n",
		       fb_hdr->unused[0], fb_hdr->unused[1]);
		return 1;
	}

	printf("name: \"%s\"\n\n", fb_hdr->name);

	printf("cmdline: \"%s\"\n", fb_hdr->cmdline);
#endif /* DEBUG */

	// TODO:  Need to incorporate more code from do_bootm() to
	// initialize 'images'. Eventually, I expect the call to
	// do_boota_linx() to mirror the call to do_bootm_linux().

	/* init kernel, ramdisk and prepare parameters */
	do_boota_linux(&images, fb_hdr);

	printf("%s, %d:  We should not come here ... \n", __FILE__, __LINE__);

	return 0;
}

U_BOOT_CMD(boota, 2, 1, do_boota,
	   "boota   - boot android bootimg from memory",
	   "<addr>\n    - boot application image stored in memory\n"
	   "\t'addr' should be the address of boot image which is kernel+ramdisk.img\n");
#endif
